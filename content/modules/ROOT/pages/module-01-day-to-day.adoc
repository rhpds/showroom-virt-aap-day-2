= Enabling Basic Day to Day Operations

== Credentials for the OpenShift Console and Ansible Automation Platform

Your OpenShift cluster console is available {openshift_cluster_console_url}[here^].

Your local admin login is available with the following credentials:

* *User:* `{openshift_cluster_admin_username}`
* *Password:* `{openshift_cluster_admin_password}`

You will first see a page that asks you to choose an authenication provider, click on *htpasswd_provider*.

image::module-01-day-to-day/00-htpasswd_login.png[title="OpenShift Authentication", link=self, window=blank, width=100%]

You will then be presented with a login screen where you can copy/paste your credentials.

image::module-01-day-to-day/01-openshift_login.png[title="OpenShift Login", link=self, window=blank, width=100%]

Your Ansible Automation Platform console is available {aap_controller_web_url}[here^].

Your admin login is available with the following credentials:

* *User:* `{aap_controller_admin_user}`
* *Password* `{aap_controller_admin_password}`

image::module-01-day-to-day/02-aap_login.png[title="AAP Login", link=self, window=blank, width=100%]

Use this opportunity to open and log into both consoles to prepare for the lab.


[[dynamic_inventory]]
== Creating a Dynamic Inventory for OpenShift Virtual Machines

OBJECTIVE:

Dynamic inventories allow Ansible Automation Platform (AAP) to automatically fetch and update the inventory of systems from external sources, eliminating the need for manual inventory management.

In this lab, we will configure a dynamic inventory to pull data from OpenShift Virtualization. This will enable AAP to manage OpenShift VMs residing in the *vms-aap-day2* namespace of an OCP cluster.

=== Create an Inventory

. In the left-side menu, click to expand the menu for *Automation Execution*, then click on *Infrastructure*, followed by *Inventories*.
+
image::module-01-day-to-day/03-auto_infra_inv.png[title="Automation Execution, Infrastucture, Inventories", link=self, window=blank, width=100%]
+
. Click the *Create inventory* drop-down box and select the *Create inventory* option.
+
image::module-01-day-to-day/04-create_inventory_dropdown.png[title="Create Inventory Dropdown", link=self, window=blank, width=100%]
+
. Fill out or select the appropriate value from the drop down menus available for the following fields in the *Create Inventory* form:
   * *Name:* `OpenShift Virtual Machines`
   * *Organization:* Default
+
. Click the *Create inventory* button at the bottom.
+
image::module-01-day-to-day/05-create_inventory.png[title="Create Inventory", link=self, window=blank, width=100%]

=== Add a Source to the Inventory

. After creating the inventory, switch to the *Sources* tab.
+
. Select the *Create source* button.
+
image::module-01-day-to-day/06-sources_tab.png[title="Sources Tab", link=self, window=blank, width=100%]
+
. Fill out or select the appropriate value from the drop down menus available for the following fields in the *Create Source* form:
   * *Name:* OpenShift Virtual Machines Source
   * *Execution environment:* Day 2 EE
   * *Source:* OpenShift Virtualization
   * *Credential:* OpenShift Credential
   * *Update on launch Checkbox*: Checked
   * *Cache timeout (seconds):* 0
+
. Copy and paste the following YAML snippet into the *Source variables* field on the form.
+
[source,yaml,role=execute,subs="attributes"]
----
namespaces:
  - vms-aap-day2
----
+
. Click the *Create source* button to save the configuration.
+
image::module-01-day-to-day/07-create_inventory_source.png[title="Create Inventory Source", link=self, window=blank, width=100%]

===  Update the Inventory
. Click the *Launch Inventory Update* button in the top-right corner to start inventory collection.
+
image::module-01-day-to-day/08-update_inventory.png[title="Update Inventory", link=self, window=blank, width=100%]
+
. Wait for the *Last Job Status* to show *Success*.
+
image::module-01-day-to-day/09-job_status_success.png[title="Job Status Success", link=self, window=blank, width=100%]
+
. Click on the tab for *Back to Inventory Sources*.
+
image::module-01-day-to-day/10-back_to_inventory_sources.png[title="Back to Inventory Sources", link=self, window=blank, width=100%]
+
. Switch to the *Hosts* tab at the top of the screen.
. Confirm that the Virtual Machines from the *vms-app-day2* namespace of your OpenShift cluster are listed as inventory hosts.
+
image::module-01-day-to-day/11-verify_hosts.png[title="Verify Hosts", link=self, window=blank, width=100%]
+
. To verify that the machines are alive we can select the three VMs we have discovered and run an automated *ping* job against them by clicking the *Run command* button.
+
image::module-01-day-to-day/12-run_command.png[title="Run Command", link=self, window=blank, width=100%]
+
. You will be presented with the *Run command* wizard with several pages:
   * On the *Details* page, select *ping* from the *Module* dropdown menu, and click *Next*.
   * On the *Execution Environment* page, select *Day2 EE* from the *Execution Environment* dropdown, and click *Next*.
   * On the *Credential* page, select *Workshop Credential* from the *Credential* dropdown, and click *Next*.
   * On the *Review* page, check over your selected options, and when you are ready click the *Finish* button.
+
image::module-01-day-to-day/13-review_run_command.png[title="Review Run Command", link=self, window=blank, width=100%]
+
. The output of running the command should be similar to the output below, including the names of each VM and their status:
+
----
vms-aap-day2-rhel9-vm1 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
vms-aap-day2-rhel9-vm2 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
vms-aap-day2-rhel9-vm3 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
----
+
image::module-01-day-to-day/14-ping_success.png[title="Ping Success", link=self, window=blank, width=100%]
+
NOTE: You may also confirm the VMs are running in a manual manner by logging into your OpenShift console, and viewing the virtual machines there manually.

=== Verifying VM Inventory in the OpenShift Console
. Switch to your OpenShift administration console window.
. On the left side navigation menu, click on *Virtualization* and then *VirtualMachines*.
. Highlight the *vms-aap-day2* project in the central navigation column.
. Confirm that the virtual machines are running.
+
image::module-01-day-to-day/15-vm_inventory_openshift.png[title="Virtual Machines Running on OpenShift", link=self, window=blank, width=100%]

[[sec_and_comp]]
== Security and Compliance Using the OpenShift Compliance Operator

This section of our lab will focus on making use of the OpenShift Compliance Operator to configure security scans in your OpenShift cluster. The compliance operator can help ensure that the hosts in your OpenShift environment meet specific security standards, and are deployed to meet those standards.

image::module-01-day-to-day/15a-compliance_overview.png[title="Compliance Overview", link=self, window=blank, width=100%]

. Select *Operators* and then *Installed Operators* from the left side navigation menu, confirm that you have selected *All Projects* and select the *Compliance Operator*.
+
image::module-01-day-to-day/16-compliance_operator.png[title="Compliance Operator", link=self, window=blank, width=100%]
+
. This takes you to the *Operator details* page, use the horizontal scrollbar to move across and locate the *ScanSetting* tab.
+
image::module-01-day-to-day/17-compliance_details.png[title="Compliance Details", link=self, window=blank, width=100%]
+
. Click the *Create ScanSetting* button.
+
image::module-01-day-to-day/18-scansetting_button.png[title="Create ScanSetting Button", link=self, window=blank, width=100%]
+
. On the *Create ScanSetting* page, set the name of the scan to `scan01`.
Then click the *YAML view* radio button.
+
image::module-01-day-to-day/19-create_scansetting.png[title="Create Scansetting", link=self, window=blank, width=100%]
+
. In the ScanSetting YAML details, make note of the following values that are set by default:
  * The *autoApplyRemediations* field is set to *false*.
  * The *roles* to be scanned by default include both *worker* and *master* nodes.
  * The *name* field is set to *scan01* which you entered on the form view.
. Click the *Create* button to create this simple scansetting definition.
+
image::module-01-day-to-day/20-scansetting_details.png[title="ScanSetting Details", link=self, window=blank, width=100%]
+
. Now click on the *Profile* tab where there are a number of pre-defined scanning profiles.
. In the search box, type `rhcos4` and locate the FedRamp moderate profile *rhcos4-moderate* in the list.
+
image::module-01-day-to-day/21-profiles_detail.png[title="Profiles Detail", link=self, window=blank, width=100%]
+
. Click on *rhcos4-moderate* and then on the *YAML*.
Scroll down the output to browse the rules that are enforced as a part of this scan.
A quick glimpse at the side panel shows that there are quite a few of them.
+
image::module-01-day-to-day/22-rhcos4_mod_rules.png[title="RHCOS4-Moderate Rules", link=self, window=blank, width=100%]
+
. When you are done reviewing the rules, return to the *Operator details* page by clicking your browser's _back button_ twice.
+
NOTE: Additional details on the profiles available can be found https://docs.redhat.com/en/documentation/openshift_container_platform/4.18/html/security_and_compliance/compliance-operator#compliance-operator-supported-profiles[here^].
+
. Next we want to create a *ScanSettingBinding*, pairing a *Profile* with our *ScanSetting* definition we created.
We do this by navigating to the *Scan Setting Binding* tab, and clicking the *Create ScanSettingBinding* button.
+
image::module-01-day-to-day/23-create_scansettingbinding.png[title="Create ScanSettingBinding", link=self, window=blank, width=100%]
+
. In the ScanSettingBinding YAML details, let us make a few changes:
  * The *metadata/name* value should be set to `fedramp01`
  * The *settingsRef/name* field is set to `scan01` which we created earlier.
. Click the *Create* button.
+
NOTE: The profile is set to rhcos4-moderate (the fedramp moderate profile) by default.
+
image::module-01-day-to-day/24-scansettingbinding_details.png[title="ScanSettingBinding Details", link=self, window=blank, width=100%]
+
. After the *ScanSettingBinding* is created, the fedramp01 scan will be run automatically.
You can view this on the *Compliance Suite* tab.
+
image::module-01-day-to-day/25-compliance_suite.png[title="Compliance Suite", link=self, window=blank, width=100%]
+
. This Compliance Suite runs the defined scans against the specified nodes, in our case the masters and the workers defined in *scan01*.
. You can watch as the scan proceeds through the steps of *RUNNING, AGGREGATING, and DONE* by clicking on the *Compliance Scan* tab.
+
image::module-01-day-to-day/26-compliance_scan.png[title="Compliance Scan", link=self, window=blank, width=100%]
+
. Once the scan completes (3-4 minutes on average) you can check your results by clicking on the *ComplianceCheckResult* tab.
+
. Change the search bar to *Label* and apply the following labels:
  * `compliance.openshift.io/check-status=FAIL`
  * `compliance.openshift.io/check-severity=high`
+
image::module-01-day-to-day/27-compliance_check_results.png[title="Compliance Check Results", link=self, window=blank, width=100%]
+
. Twelve high severity checks have a failed status:

|===
| *ComplianceCheckResult* | *Check-Severity* | *Check-Status*
| rhcos4-moderate-master-configure-crypto-policy| high| FAIL
| rhcos4-moderate-master-coreos-pti-kernel-argument| high| FAIL
| rhcos4-moderate-master-disable-ctrlaltdel-burstaction| high| FAIL
| rhcos4-moderate-master-disable-ctrlaltdel-reboot| high| FAIL
| rhcos4-moderate-master-enable-fips-mode| high| FAIL
| rhcos4-moderate-master-no-empty-passwords| high| FAIL
| rhcos4-moderate-worker-configure-crypto-policy| high| FAIL
| rhcos4-moderate-worker-coreos-pti-kernel-argument| high| FAIL
| rhcos4-moderate-worker-disable-ctrlaltdel-burstaction| high| FAIL
| rhcos4-moderate-worker-disable-ctrlaltdel-reboot| high| FAIL
| rhcos4-moderate-worker-enable-fips-mode| high| FAIL
| rhcos4-moderate-worker-no-empty-passwords| high| FAIL
|===

You have now completed this section on configuring and running compliance scans against your OpenShift cluster.

[[net_policy]]
== Configure Network Policies to Manage VM Traffic

In Red Hat OpenShift administrators can configure Network Policies to further secure their environments, and the virtual guests that run there.
In this portion of the lab we are going to configure a virtual machine and then apply a network policy that prevents its egress to the world.

=== Confirm Network Egress on Virtual Machines

. On the left side navigation menu, click on *Virtualization* then click *VirtualMachines*, and select the *rhel9-vm1* virtual machine under the *vms-aap-day2* project in the center column.
+
image::module-01-day-to-day/28-view_vm.png[title="View VM", link=self, window=blank, width=100%]
+
. Click on the *Console* tab and use the provided credentials, and the built in copy/paste functionality to authenticate to the VM.
+
image::module-01-day-to-day/29-login_vm.png[title="Login to VM", link=self, window=blank, width=100%]
+
NOTE: You may see a popup that asks you to enable the copy/paste functionality. If prompted click *Allow*.
+
. Once you are logged in, execute the following command to start an outward bound ping to Google:
+
[source,sh,role=execute]
----
ping www.google.com
----
+
image::module-01-day-to-day/30-ping_site.png[title="Ping Google", link=self, window=blank, width=100%]
+
. Press *Control+C* to stop the ping.
+
. From the left side navigation menu, click on *Workloads* and then *Pods*, and then click on the virt-launcher pod for the one that represents the VM *rhel9-vm1* to view the pod details.
+
image::module-01-day-to-day/31-select_pod.png[title="Select Pod", link=self, window=blank, width=100%]
+
NOTE: Pod names are randomly generated, so yours will most likely not match the screenshot above.
+
. On the *Pod details* page, click the *Edit* option on the *Labels* section.
+
image::module-01-day-to-day/32-pod_details.png[title="Edit Pod Details", link=self, window=blank, width=100%]
+
. An *Edit labels* window will appear, you can click into the center box and add a label for `app=network-policy-deny`, press the *Enter* key to commit it, and then click the *Save* button.
+
image::module-01-day-to-day/33-pod_labels.png[title="Edit Pod Labels", link=self, window=blank, width=100%]
+
. Repeat the same process for the *rhel9-vm2* virtual machine.

=== Create the Network Policy

. From the left side navigation menu, click on *Networking* and then click on *NetworkPolicies*, then click on the *Create NetworkPolicy* button in the center of the screen.
+
image::module-01-day-to-day/34-network_policy.png[title="Network Policy", link=self, window=blank, width=100%]
+
. In *NetworkPolicies* fill out the following fields:
  * *Policy name*: `ping-egress-deny`
  * *Key*: `app`
  * *Value*: `network-policy-deny`
  * *Deny all egress traffic checkbox*: checked
+
image::module-01-day-to-day/35-network_policy_configure.png[title="Configure Network Policy", link=self, window=blank, width=100%]
+
. With the values filled out, you can click the *affected pods* link under the *Pod selector* section to show which pods are affected by this policy.
Once you are satisfied with your settings you can click the *Create* button.
+
image::module-01-day-to-day/36-affected_pods.png[title="Affected Pods", link=self, window=blank, width=100%]
+
. With the policy created, go test it out.

=== Confirm the Effects of the Network Policy on the VM.

. Return to the console of the *rhel9-vm1* virtual machine to test our policy.
. Using the left side navigation menu, click on *Virtualization*, then *VirtualMachines*, and select *rhel9-vm1* from the center column.
. Click the *Console* tab of the VM, you should still be logged in from before.
. Copy and paste the following syntax to test out the new Network Policy:
+
[source,sh,role=execute]
----
ping www.google.com
----
+
image::module-01-day-to-day/37-ping_site_deny.png[title="Egress Blocked", link=self, window=blank, width=100%]
+
. Egress from the cluster is completely blocked, including DNS lookups.
. Once you have completed this exercise, return to *Networking* and *NetworkPolicies* and delete the *ping-egress-deny* policy using the three-dot menu on the right, and confirming in the popup box.
+
image::module-01-day-to-day/38-delete_policy.png[title="Delete Policy", link=self, window=blank, width=100%]

In this section we learned how to apply a simple network policy to block egress traffic from a virtual machine to a public website.
While this is a very simple example and application of this function, network policies are quite feature rich and very tuneable.
In an advanced example, they can allow you to implement microsegmentation policies helping to shape the traffic flow both inside and outside of your cluster, between virtual guests in different or even the same OpenShift project.

[[alerts_graphs_logs]]
== Enable and Explore Alerts, Graphs, and Logs

Another important task for administrators is often to be able to assess cluster performance. These performance metrics can be gathered from the nodes themselves, or the workloads that are running within the cluster. OpenShift has a number of built-in tools that assist with generating alerts, aggregating logs, and producing graphs that can help an administrator visualize the performance of their cluster.

=== Node Alerts and Graphs

To begin, lets look at the metrics for the nodes that make up our cluster.

. On the left side navigation menut click on *Compute*, and then click on *Nodes*.
. From the *Nodes* page, you can se each node in your cluster, their status, role, the number of pods they are currently hosting, and physical attributes like memory and cpu utilization.
+
image::module-01-day-to-day/39-node_list.png[title="Nodes", link=self, window=blank, width=100%]
+
. Click on your worker node 4 in your cluster. The *Node details* page comes up where you can see more detailed information about the node.
. The page shows alerts that are being generated by the node at the top-center of the screen, and provides graphs to help visualize the utilization of the node by displaying CPU, Memory, Storage, and Network Throughput graphs at the bottom-center of the screen.
. You can change the review period for these graphs to periods of 1, 6, or 24 hours by clicking on the dropdown at the top-right of the utilization panel.
+
image::module-01-day-to-day/40-node_example.png[title="Node Details", link=self, window=blank, width=100%]


=== Virtual Machine Graphs

Outside of the physical cluster resources, it's also very important to be able to visualize what's going on with our applications and workloads like virtual machines. Lets examine the information we can find out about these.

NOTE: For this part of the lab, we are going to use an application to generate additional load on some of our virtual machines so that we can see how graphs are generated.

. Using the left side navigation menu click on *Workloads* followed by *Deployments*.
. Make sure to ensure you are in Project: *windows-vms*.
. You should see one pod deployed here called *loadmaker*.
+
image::module-01-day-to-day/41-select_loadmaker.png[title="Loadmaker Deployment", link=self, window=blank, width=100%]
+
. Click on *loadmaker* and it will bring up the *Deployment details* page.
+
image::module-01-day-to-day/42-deploy_details.png[title="Deployment Details", link=self, window=blank, width=100%]
+
. Click on *Environment*, you will see a field for *REQUESTS_PER_SECOND*, change the value in the field to `75` and click the *Save* button at the bottom.
+
image::module-01-day-to-day/43-lm_pod_config.png[title="LM Pod Config", link=self, window=blank, width=100%]
+
. Now lets go check on the VM's that we are generating load against.
. On the left side navigation menu click on *Virtualization* and then *VirtualMachines*. Select the *windows-vms* project in the center column. You should see three virtual machines: *winweb01*, *winweb02*, and *database*.
+
image::module-01-day-to-day/44-windows_vms.png[title="Windows VMs", link=self, window=blank, width=100%]
+
IMPORTANT: At this point in the lab only *database* and *winweb01* should be powered on. If they are off, please power them on now. Do not power on *winweb02* for the time being.
+
. Once the virtual machines are running, click on *winweb01*. This will bring you to the *VirtualMachine details* page.
. On this page there is a  a *Utilization* section that shows the following information:
  * The basic status of the VM resources (cpu, memory, storage, and network transfer) which are updated every 15 seconds.
  * A number of small graphs which detail the VM performance over a recent time period, by default this is the last 5 minutes, but we can select a value up to 1 week from the drop down menu.
+
image::module-01-day-to-day/45-vm_details.png[title="VM Details", link=self, window=blank, width=100%]
+
. Taking a closer look at *Network Transfer* by clicking on *Breakdown by network* you can see how much network traffic is passing through each network adapter assigned to the virtual machine. In this case, the one *default* network adapter.
+
image::module-01-day-to-day/46-select_network.png[title="Select Network", link=self, window=blank, width=100%]
+
. When you are done looking at the network adapter, click on the graph showing CPU utilization.
+
image::module-01-day-to-day/47-select_cpu.png[title="Select CPU", link=self, window=blank, width=100%]
+
. This will launch the *Metrics* window which will allow you to see more details about the CPU utilization. By default this is set to 30 minutes, but you can click on the drop down and change that to 1 hour to see the spike in the graph once we turned on the load generator.
+
image::module-01-day-to-day/48-cpu_metrics.png[title="CPU Metrics", link=self, window=blank, width=100%]
+
. You can also modify the refresh timing in the upper right corner.
+
image::module-01-day-to-day/49-change_refresh.png[title="Change Refresh Interval", link=self, window=blank, width=100%]
+
. You can also see the query that is being run against the VM in order to generate this graph, and create your own using the *Add Query* button.
+
image::module-01-day-to-day/50-add_query.png[title="Add_Query", link=self, window=blank, width=100%]
+
. As an exercise, lets add a custom query that will show the amount of vCPU time spent in IO/wait status.
. Click the *Add Query* button, and on the new line that appears, paste the following query:
+
[source,sh,role=execute]
----
sum(rate(kubevirt_vmi_vcpu_wait_seconds_total{name='winweb01',namespace='windows-vms'}[5m])) BY (name, namespace)
----
+
. Click the *Run queries* button and see how the graph updates. A new line graph will appear showing that the vCPU on the guest is never not under load.
+
image::module-01-day-to-day/51-example_query.png[title="Sample Custom Query", link=self, window=blank, width=100%]

=== Examining Dashboards

Another powerful feature of OpenShift is being able to use the *Cluster Observability Operator* to display detailed dashboards of cluster performance. Lets check some of those out now.

. From the left side navigation menu, click on *Observe*, and then *Dashboards*.
+
image::module-01-day-to-day/52-dashboards.png[title="Dashboards", link=self, window=blank, width=100%]
+
. Click on *API Performance* and search for *KubeVirt/Infrastructure Resources/Top Consumers*
+
image::module-01-day-to-day/53-kubevirt_dashboard.png[title="KubeVirt Dashboard", link=self, window=blank, width=100%]
+
. This dashboard will display the top consumers for all of the virtual machines running on your cluster. Look at the *Top Consumers of CPU by virt-launcher Pods* panel and click the *Inspect* link in the upper right corner.
+
image::module-01-day-to-day/54-cpu_inspect.png[title="CPU Inspect", link=self, window=blank, width=100%]
+
. You can can select the VMs you want to see in the graph by checking the boxes next to each VM displayed.
. Try it now by turning some of the lines off. The associated colored line will disappear from the graph when disabled.
+
image::module-01-day-to-day/55-metrics_select.png[title="Select Metrics", link=self, window=blank, width=100%]

Now that we have completed this section determining how to locate and display alerts, performance metrics, and graphs about our nodes and workloads, we can leverage these skills in the future in order to troubleshoot our own OpenShift Virtualization environments.

[[vm_mgmt_power]]
== Automated VM Management

=== Stop, Start, Restart Guest VMs

Now that we've spent some time working with the OpenShift console, lets see what types of activities we can automate to make our administration jobs easier.

In this section, you'll learn how to manage the lifecycle of your guest VMs running in Red Hat OpenShift Virtualization using Ansible Automation
Platform (AAP).

While much of the groundwork, such as creating playbooks and VM task files, has already been completed for you, this section of the lab will focus on understanding how the pieces work together and how to run the automation via AAP.

To begin, we’ll perform some common VM lifecycle actions such as stopping, starting, and restarting all VMs in a given namespace. These tasks are designed to demonstrate how the automation behind these actions is structured.

=== The Existing Setup

To assist with your experience, the following content has already been created and configured for you:

* The *tasks/main.yml* file has been pre-populated with dynamic task inclusion logic.
* The Ansible playbook (*manage_vm_playbook.yml*) that calls the appropriate task based on input variables is already in place.
* Individual task files for stopping, starting, and restarting VMs (*stop_vm.yml*, *start_vm.yml*, and *restart_vm.yml*) have been pre-written.

Although you don’t need to create or modify these files, it's important to understand how they work, as you’ll be referencing them when creating job templates in Ansible Automation Platform.

=== Understanding the Task Files

Each of the task files works by retrieving all virtual machines within a specific namespace (in our case *vms-aap-day2*), and then performing an action (stop, start, restart) based on their current status.
The *ansible.builtin.debug* task provides insights to understanding the structure of your VM resource *vm_info* to identify key fields required to create dynamic Ansible tasks.

=== stop_vm.yml

This task file stops any VMs that are currently running within a given namespace.

[source,yaml]
----
---
- name: Get all VirtualMachines in the namespace
  redhat.openshift_virtualization.kubevirt_vm_info:
    namespace: "{{ vm_namespace }}"
  register: vm_info

- name: Debug the vm_info variable
  ansible.builtin.debug:
    var: vm_info

- name: Stop VM using OpenShift API
  ansible.builtin.uri:
    url: "{{ OCP_HOST }}/apis/subresources.kubevirt.io/v1/namespaces/{{ vm_namespace }}/virtualmachines/{{ item.metadata.name }}/stop"
    method: PUT
    headers:
      Authorization: "Bearer {{ OCP_BEARER_TOKEN }}"
    validate_certs: false
    status_code:
      - 202
  loop: "{{ vm_info.resources }}"
  loop_control:
    label: "{{ item.metadata.name }}"
  changed_when: item.status.printableStatus != "Stopped"
----

=== start_vm.yml

This task file starts any VMs that are currently stopped within a given namespace.

[source,yaml]
----
---
- name: Get all VirtualMachines in the namespace
  redhat.openshift_virtualization.kubevirt_vm_info:
    namespace: "{{ vm_namespace }}"
  register: vm_info

- name: Debug the vm_info variable
  ansible.builtin.debug:
    var: vm_info

- name: Start VM using OpenShift API
  ansible.builtin.uri:
    url: "{{ OCP_HOST }}/apis/subresources.kubevirt.io/v1/namespaces/{{ vm_namespace }}/virtualmachines/{{ item.metadata.name }}/start"
    method: PUT
    headers:
      Authorization: "Bearer {{ OCP_BEARER_TOKEN }}"
    validate_certs: false
    status_code:
      - 202
  loop: "{{ vm_info.resources }}"
  loop_control:
    label: "{{ item.metadata.name }}"
  changed_when: item.status.printableStatus != "Running"
----

=== restart_vm.yml

This task file restarts any VMs that are currently running within a given namespace.

[source,yaml]
----
---
- name: Get all VirtualMachines in the namespace
  redhat.openshift_virtualization.kubevirt_vm_info:
    namespace: "{{ vm_namespace }}"
  register: vm_info

- name: Debug the vm_info variable
  ansible.builtin.debug:
    var: vm_info

- name: Restart VM using OpenShift API
  ansible.builtin.uri:
    url: "{{ OCP_HOST }}/apis/subresources.kubevirt.io/v1/namespaces/{{ vm_namespace }}/virtualmachines/{{ item.metadata.name }}/restart"
    method: PUT
    headers:
      Authorization: "Bearer {{ OCP_BEARER_TOKEN }}"
    validate_certs: false
    status_code:
      - 202
  loop: "{{ vm_info.resources }}"
  loop_control:
    label: "{{ item.metadata.name }}"
  changed_when: item.status.printableStatus != "Running"
----

These task files interact with the OpenShift REST API directly using the *ansible.builtin.uri* module to invoke the appropriate lifecycle action of stopping, starting, or restarting the virtual machine.

In addition, the debug task helps you to visualize the structure of VM data returned by the *kubevirt_vm_info* module and breaks down as follows:

* The *kubevirt_vm_info* module retrieves all VMs in the namespace.
* *metadata.name*: The name of the VirtualMachine.
* *metadata.namespace*: The namespace the VM belongs to.
* The *loop_control* option sets a label for each task iteration, showing the VM name (*item.metadata.name*) in the output. This makes the playbook output more readable and easier to debug.
* *status.printableStatus*: The current status of the VM (e.g., Stop, Start,Restart).

A snippet sample of the *ansible.builtin.debug* module is shown below.

[source,yaml]
----
changed: true
result:
  apiVersion: kubevirt.io/v1
  kind: VirtualMachine
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: >
        ...
    ...
    name: rhel9-vm1
    namespace: vms-aap-day2
  spec:
    ...
  status:
    ...
    printableStatus: Stopped
  ...
----

=== Creating and Running the VM Job Templates with Ansible Automation Platform

Each VM lifecycle template that you will create takes advantage of the *manage_vm_playbook.yml*.

In this section, you will make use of the Ansible Automation Platform (AAP) dashboard and create a VM Job Template for each scenario: Start VMs, Stop VMs, and Restart VMs. You will be able to see the effects of your automation jobs by checking back with the OpenShift console.

. In the OpenShift console, use the left side navigation menu and click on *Virtualization* and then *VirtualMachines*. In the center column, click on the *vms-aap-day2* project and verify that all three VMs are currently running.
+
image::module-01-day-to-day/55a-running_vms.png[title="Running AAP VMs", link=self, window=blank, width=100%]
+
. Return to the tab where you have Ansible Automation Platform open. If your previous login has timed out, or you have accidentally closed the window, the information to login again is here:
+
Your Ansible Automation Platform console is available {aap_controller_web_url}[here^].

Your admin login is available with the following credentials:

* *User:* `{aap_controller_admin_user}`
* *Password* `{aap_controller_admin_password}`
+
. Within the AAP UI dashboard, use the left side menu to navigate to *Automation Execution* then click on *Templates*. On the templates screen, click the *Create template* button, and chose *Create job template* from the dropdown menu.
+
image::module-01-day-to-day/56-create_job_template.png[title="Create Job Template", link=self, window=blank, width=100%]
+
. Fill out the following details on the *Create job template* page:
+
|===
| Parameter         | Value

| Name          | `Stop VMs`
| Job Type      | Run
| Inventory     | OpenShift Virtual Machines
| Project       | Workshop Project
| Playbook      | solutions/manage_vm_playbook.yml
| Execution Environment | Day2 EE
| Credentials   | OpenShift Credential
| Extra variables            | `vm_namespace: vms-aap-day2` +
                               `task_file: stop_vm.yml`
|===
+
. Once filled out, click the *Create job template* button.
+
image::module-01-day-to-day/57-stop_vms_template.png[title="Stop VMs Template", link=self, window=blank, width=100%]
+
. Once the *Stop VMs* Job Template is created, select the *Launch template* button on the top right corner to run the job.
+
image::module-01-day-to-day/58-launch_stop_vms.png[title="Launch Stop VMs Template", link=self, window=blank, width=100%]
+
. The job will start running, and once it is successful you will see changes displayed in yellow.
+
image::module-01-day-to-day/59-successful_job.png[title="Successful Job", link=self, window=blank, width=100%]
+
. Return to the OpenShift console to see that the virtual machines in the *vms-aap-day2* project have all now stopped.
+
image::module-01-day-to-day/60-stopped_vms.png[title="Stopped VMs", link=self, window=blank, width=100%]
+
. Return to the AAP Dashboard, and repeat this process to create the *Start VMs* and *Restart VMs* Ansible Job Templates. The details for each is provided below.

. For Starting VMs, use the following details to create the job template:
+
|===
| Parameter         | Value

| Name          | `Start VMs`
| Job Type      | Run
| Inventory     | OpenShift Virtual Machines
| Project       | Workshop Project
| Playbook      | solutions/manage_vm_playbook.yml
| Execution Environment | Day2 EE
| Credentials   | OpenShift Credential
| Extra variables            | `vm_namespace: vms-aap-day2` +
                               `task_file: start_vm.yml`
|===
+
. For Restarting VMs, use the following details to create the job template:
+
|===
| Parameter         | Value

| *Name*          | `Restart VMs`
| *Job Type*      | Run
| *Inventory*     | OpenShift Virtual Machines
| *Project*       | Workshop Project
| *Playbook*      | solutions/manage_vm_playbook.yml
| *Execution Environment* | Day2 EE
| *Credentials*   | OpenShift Credential
| Extra variables            | `vm_namespace: vms-aap-day2` +
                               `task_file: restart_vm.yml`
|===
+
. Once you have created these Job templates select the *Launch template* button on the top right corner to run the job and notice the changes of these VMs within the OpenShift console. Each VM should start back up after executing the *Start VMs* template, and then each machine should reboot after executing the *Restrat VMs* template.

[[vm_mgmt_patch]]
=== Patching your VMs

In this exercise, you’ll automate the patching of RHEL virtual machines by applying only security-related updates using Ansible Automation Platform.

The virtual machines you'll target are already part of the dynamic inventory that was set up in a previous step — specifically, the *OpenShift Virtual Machines* inventory.

Rather than writing playbooks or tasks from scratch, you'll be working with provided automation content, which includes:

* A task file that performs security updates using the dnf module.
* A playbook that executes roles that are responsible for system registration and patching.

Your goal is to understand what this content does and then create a Job Template to execute the automation using Ansible Automation Platform’s web UI.

NOTE: This lab uses Vault Credentials to securely handle sensitive authentication data and a subscription management role to register RHEL systems to Red Hat. This ensures VMs have access to the correct repositories for updates and demonstrates secure automation practices.

==== Understanding the Provided Task File: update_security_packages.yml

This task file lives inside the tasks/ directory of the redhatone.vm_management.vm_management role. It uses the ansible.builtin.dnf module to scan for and install the latest security-related updates on all hosts in the inventory.

[source,yaml]
----
- name: Update security-related packages on all hosts
  ansible.builtin.dnf:
    name: "*" <1>
    security: true <2>
    state: latest <3>
----
<1> name: "*" — Targets all available packages.
<2> security: true — Filters for only security-related updates.
<3> state: latest — Ensures the latest available security updates are installed.

This task is designed to be modular.
It is included in your role and can be triggered from any playbook using a variable like *task_file*, which will be used shortly.

=== Understanding the Provided Playbook: patch_vm_playbook.yml

This playbook is responsible for executing the logic that handles both system registration and patching.
It is already present in your project directory.

[source,yaml]
----
- name: Patch Virtual Machines
  hosts: all
  roles:
    - redhatone.vm_management.rhsm_subscription <1>
    - redhatone.vm_management.vm_management <2>
----
<1> redhatone.vm_management.rhsm_subscription: Registers the RHEL VMs to Red Hat using credentials provided via Vault. This step ensures the systems have access to the necessary repositories for receiving updates.
<2> redhatone.vm_management.vm_management: Calls the role that includes the security update task (update_security_packages.yml), referenced via the task_file variable.

The playbook ensures that every target host goes through both registration and patching in the correct order.

==== Creating the Patch VMs Job Template in Ansible Automation Platform

Now lets connect all the pieces through the AAP web interface and run the automation using a Job Template.

. Using the left side navigation bar, click on *Automation Execution* and then *Templates*.
. Click on the *Create template* button, and then select *Create job template* from the dropdown menu.
+
image::module-01-day-to-day/61-create_job_template.png[title="Stop VMs Template", link=self, window=blank, width=100%]
+
. On the *Create job template* page, fill out the following fields:
+
|===
| Parameter               | Value

| Name                    | `Patch VMs`
| Job Type                | Run
| Inventory               | OpenShift Virtual Machines
| Project                 | Workshop Project
| Playbook                | solutions/patch_playbook.yml
| Execution Environment   | Day2 EE
| Credentials             | Workshop Credential, Vault Credential
| Extra Variables         | `task_file: update_security_packages.yml`
| Privilege Escalation    | Enabled

|===
+
IMPORTANT: Notice there are two credentials attached and privilege escalation is enabled.
+
. Once the form is filled out, click the *Create job template* button.
+
image::module-01-day-to-day/62-create_patch_template.png[title="Create Patch Template", link=self, window=blank, width=100%]
+
. Once created, click *Launch Template* button in the top-right corner to start the job.
. When the *Patch VMs* job has completed successfully, you should see output similar to:
+
image::module-01-day-to-day/63-patch_vm.png[title="Patch VM", link=self, window=blank, width=100%]

==== Reviewing the Job Output

After the job runs, you’ll be able to see:

* A task-by-task breakdown showing which operations were performed.
* Output for the task titled *Update security-related packages on all hosts*.
* Per-host details indicating which security updates were applied.

. Under the *TASK* for *Update security-related packages on all hosts*, click on *vms-aap-day2-rhel9-vm1*.
+
image::module-01-day-to-day/64-patch_complete.png[title="Patching Complete", link=self, window=blank, width=100%]
+
. You will be presented with additional *Details* about the task, and be able to validate that system was indeed patched by our automation job by clicking on the *Data* tab.
+
image::module-01-day-to-day/65-patch_details.png[title="Patch Details", link=self, window=blank, width=100%]

[[vm_mgmt_hp]]
=== Hot-Plugging CPU and Memory Resources

One of the great benefits of having virtual workloads is the ability to adjust the resources used by those workloads on the fly to meet workload demands. Compared to the days of having to shut down the server to physically add RAM or upgrade the processor, the ability to scale VM resources dynamically by hot-plugging additional resources is a fantastic timesaver. Also, being able to automate the scaling up and down of these requests using Ansible Automation Platform based on metrics gathered from the guests ensures efficiency in both resource consumption and physical administrative time.

In this section, you will learn how to hot-plug CPU and memory resources into a running Virtual Machine (VM) using Ansible Automation Platform and the redhat.openshift_virtualization collection.

Hot-plugging is the ability to add or remove hardware resources, such as CPU or memory, to a running VM without requiring a reboot. This capability is critical for dynamic workloads, allowing you to scale resources based on demand while minimizing downtime.

This exercise focuses on using *instance types*, which are reusable objects in OpenShift Virtualization that define the resources and characteristics for VMs. Instance types simplify resource management by enabling consistent configurations across VMs.

==== What Are Instance Types?

An instance type is a reusable configuration object where you define resources (like CPU and memory) and characteristics for new VMs.
OpenShift Virtualization provides two types of instance types:

. *VirtualMachineInstancetype*: A namespaced object for instance types limited to a specific namespace.
. *VirtualMachineClusterInstancetype*: A cluster-wide object for instance types available across all namespaces.

Both types share the same VirtualMachineInstancetypeSpec, which allows you to define custom configurations or use the variety of instance types included by default when OpenShift Virtualization is installed.

By using instance types, you can simplify VM configuration management and ensure consistency throughout all your deployments, making them the *recommended approach* for hot-plugging resources.

In this lab, you will primarily focus on using the instance type method while also learning about the classic approach of directly modifying the VM specification for context.

NOTE: The classic method only works when creating VMs that do not use an instance type.

==== How to Identify if a VM Uses Instance Types or Not?

To determine whether a VM is created with an instance type or not, follow these steps:

. Navigate to the *Overview* tab of the *rhel9-vm1* in the OpenShift Virtualization console.
. In the *Details* section, look for the following:
   - *Instance Type*: If the VM uses an instance type, this field will display the name of the instance type applied to the VM (e.g., u1.small).
   - *Template*: If no instance type is used, this field will display either None or the name of the template used to create the VM.
+
image::module-01-day-to-day/66-vm_details.png[title="VM Details", link=self, window=blank, width=100%]

The instance_type method is the recommended approach for hot-plugging resources into a VM. It ensures consistent and reusable resource configurations across multiple VMs while leveraging the powerful features of OpenShift Virtualization.

==== Using the Pre-created hot_plug.yml File to Update Resources

The hot_plug.yml file consists of a task that updates a running VM by applying a new instance type. This approach lets you add CPU and memory resources dynamically without needing to recreate or power off the VM.

[source, yaml]
----
- name: Swap Instance Type to add more Resources
  redhat.openshift_virtualization.kubevirt_vm: <1>
    name: "rhel9-vm1" <2>
    namespace: "{{ vm_namespace }}" <3>
    state: present <4>
    run_strategy: RestartOnError <5>
    instancetype: <6>
      name: "{{ instance_type }}" <7>
      revisionName: "" <8>
----
<1> *redhat.openshift_virtualization.kubevirt_vm*: Specifies the module used to manage VMs in OpenShift Virtualization.
<2> *name*: The name of the VM to which the new resources will be applied.
<3> *namespace*: The namespace in which the VM resides.
<4> *state*: Ensures the VM is present and available.
<5> *run_strategy*: Restarts the VM in case of errors, does not start machines stopped manually.
<6> *instancetype*: Defines the instance type for the VM, allowing you to use pre-configured or custom resource settings.
<7> *instancetype.name*: The name of the instance type to be applied.
<8> *instancetype.revisionName*: Optionally specifies the exact revision of the instance type, ensuring compatibility with the VM. It is typically auto-generated, thus left empty.

NOTE: VMs must be created using Instance Types for this task method to work. Otherwise you must use the Classic method.

==== Classic Method: Modifying the Spec Directly (Informational Only)

The classic method involves directly modifying the VM's spec file to update CPU and memory resources.
While this approach is flexible, it lacks the reusability and consistency offered by instance types, making it less ideal for managing resources across multiple VMs.

[source, yaml]
----
- name: Modify CPU & Memory Resources
  redhat.openshift_virtualization.kubevirt_vm: <1>
    name: "rhel9-vm2" <2>
    namespace: "{{ vm_namespace }}" <3>
    state: present <4>
    spec: <5>
      domain: <6>
        cpu: <7>
          sockets: 2
        memory: <8>
          guest: 4Gi
----
<1> *redhat.openshift_virtualization.kubevirt_vm*: Specifies the module used to manage VMs in OpenShift Virtualization.
<2> *name*: The name of the VM being modified.
<3> *namespace*: The namespace in which the VM resides.
<4> *state*: Ensures the VM is in the desired state, in this case, present.
<5> *spec*: Directly modifies the VM's specification.
<6> *spec.domain*: Contains settings related to the VM's virtualized environment.
<7> *spec.domain.cpu*: Specifies the number of CPU sockets for the VM (e.g., 2).
<8> *spec.domain.memory*: Defines the memory allocated to the VM, (e.g., 4Gi).

NOTE: Classic VMs are not a part of this lab exercise, and the Classic Method is for informational purposes only.

==== Create and Run the Hot-Plug Job Template

. Within the AAP UI Dashboard, use the left side menu to navigate to *Automation Execution* and then click on *Templates*.
. Click *Create Template* and select *Create job template* from the dropdown menu that appears.
+
image::module-01-day-to-day/67-create_template.png[title="Create Job Template", link=self, window=blank, width=100%]
+
. Fill in the following details to create a job template:
+
[cols="2,3",options="header"]
|===
| Parameter | Value
| *Name* | `Hot Plug VMs`
| *Job Type* | Run
| *Inventory* | OpenShift Virtual Machines
| *Project* | Workshop Project
| *Playbook* | solutions/manage_vm_playbook.yml
| *Execution Environment* | Day 2 EE
| *Credentials* | OpenShift Credential
| *Extra variables* | `vm_namespace: vms-aap-day2` +
                      `task_file: hot_plug.yml` +
                      `instance_type: u1.2xmedium`
|===
+
. When the details are filled out, click *Create Job Template*.
+
image::module-01-day-to-day/68-create_hotadd_template.png[title="Create HotAdd Template", link=self, window=blank, width=100%]
+
. Launch the job by selecting the *Launch Template* button from the top-right corner. When the job completes you should see output that shows it was able to modify the virtual machines instance type.
+
image::module-01-day-to-day/69-hotadd_template_success.png[title="HotAdd Template Success", link=self, window=blank, width=100%]
+
. When the job completes, return to the OpenShift console and view the details of the rhel9-vm1 Virtual Machine once again. You should see that the *InstanceType* field has changed and is now set to *u1.2xmedium*.
+
image::module-01-day-to-day/70-vm_modified_instancetype.png[title="VM InstanceType Modified ", link=self, window=blank, width=100%]

[[vm_mgmt_backup]]
=== Backup and Restore Virtual Machines

One of the most critical aspects of virtual machine administration is ensuring business continuity through reliable backup and restore capabilities. The ability to capture point-in-time snapshots of running VMs and quickly restore them in case of disasters, system failures, or unintended changes can save organizations significant time and resources compared to traditional backup methods.

In this exercise, you'll automate the backup and restoration of Virtual Machines using VM Snapshots with Ansible Automation Platform. This capability enables you to protect your virtualized workloads at scale while maintaining operational efficiency.

Virtual Machine Snapshots in OpenShift Virtualization capture the complete state and data of a VM at a specific point in time, including all attached Container Storage Interface (CSI) volumes and VM configuration metadata. For running VMs, the QEMU guest agent coordinates I/O operations during snapshot creation, ensuring data consistency by freezing the filesystem, taking the snapshot, and then thawing the filesystem.

Snapshots are managed through three OpenShift APIs:

* *VirtualMachineSnapshot*: Represents a user request to create a snapshot and contains information about the current state of the VM
* *VirtualMachineSnapshotContent*: Represents a provisioned resource on the cluster (the actual snapshot) created by the VM snapshot controller
* *VirtualMachineRestore*: Represents a user request to restore a VM from a snapshot

=== The Existing Setup

To assist with your experience, the following content has already been created and configured for you:

* The snapshot automation tasks (*snapshot_vms.yml* and *_snapshot_vm.yml*) have been prewritten to handle the VM snapshots using a loop based approach.
* The restoration automation tasks (*restore_vm_snapshots.yml* and *_restore_vm_snapshot.yml*) have been precreated to manage the complete restoration workflow including stopping, restoring, and restarting VMs.
* The *manage_vm_playbook.yml* playbook is already configured to execute these tasks based on input variables of whether to take or restore the snapshot of the VMs.

Although you don't need to create or modify these files, it's important to understand how they work, as you'll be referencing them when creating job templates in Ansible Automation Platform.

=== Understanding the Provided Snapshot Task Files

The snapshot automation uses a two tiered approach where one task file handles multiple snapshots using loops, and an include task file takes the individual VM snapshots. 

=== snapshot_vms.yml

This main task file processes a comma-delimited string of VM names and creates individual snapshot tasks for each VM using Ansible's loop functionality.

[source,yaml]
----
---
- name: Snapshot individual VM
  ansible.builtin.include_tasks:
    file: _snapshot_vm.yml
  loop_control:
    loop_var: vm_to_snapshot
  loop: "{{ vms_to_snapshot.replace(' ','').split(',') }}"
  when: vms_to_snapshot | default('', True) | length > 0
----

**Explanation of the Task:**

* *when*: Validates that the `vms_to_snapshot` variable contains content before proceeding using filters to check variable state
* *loop*: Processes the comma-delimited VM names, removing spaces and creating a list using Jinja2 functions
* *loop_control/loop_var*: Sets the variable name (`vm_to_snapshot`) for each iteration of the loop
* *ansible.builtin.include_tasks*: Calls the included task file `_snapshot_vm.yml` for each VM that captures the necessary steps (tasks) to complete the snapshot process.

=== _snapshot_vm.yml

A task file beginning with an underscore "_" indicates that it is included within another task file. This file handles the actual snapshot creation for a single VM using OpenShift APIs and contains the core snapshot logic.

[source,yaml]
----
---
- name: Verify VM to Snapshot Provided
  ansible.builtin.assert:
    that:
      - vm_to_snapshot | default('', True) | length > 0
    quiet: True
    fail_msg: VM to Snapshot not specified

- name: Get VirtualMachine to snapshot
  redhat.openshift_virtualization.kubevirt_vm_info:
    namespace: "{{ vm_namespace }}"
    name: "{{ vm_to_snapshot }}"
  register: vm_info

- name: Create Snapshot
  redhat.openshift.k8s:
    state: present
    definition:
      apiVersion: snapshot.kubevirt.io/v1alpha1
      kind: VirtualMachineSnapshot
      metadata:
        generateName: "{{ vm_info.resources[0].metadata.name }}-"
        namespace: "{{ vm_info.resources[0].metadata.namespace }}"
        ownerReferences:
          - apiVersion: kubevirt.io/v1
            blockOwnerDeletion: false
            kind: VirtualMachine
            name: "{{ vm_info.resources[0].metadata.name }}"
            uid: "{{ vm_info.resources[0].metadata.uid }}"
      spec:
        source:
          apiGroup: kubevirt.io
          kind: VirtualMachine
          name: "{{ vm_info.resources[0].metadata.name }}"
    wait: true
    wait_condition:
      type: Ready
  when: "'resources' in vm_info and vm_info.resources | length == 1"
----

**Explanation of the Tasks:**

There are three tasks in this included task file:

. Verifies that a variable called `vm_to_snapshot` has been provided using `ansible.builtin.assert`
. Retrieves the definition of the `VirtualMachine` resource using `kubevirt_vm_info` and stores it in `vm_info`
. Creates a new `VirtualMachineSnapshot` resource using `redhat.openshift.k8s` module

Key details of the snapshot creation:

* *generateName*: OpenShift capability to generate a unique name when `name` is not provided
* *ownerReferences*: Creates a relationship between the `VirtualMachineSnapshot` and the `VirtualMachine` so that if the VM is deleted, the OpenShift garbage collector will automatically delete the snapshot
* *wait/wait_condition*: Pauses execution until the snapshot completes successfully (condition type `Ready` set to `true`)
* *when*: Ensures the snapshot is only created if exactly one VM resource was found

=== Creating and Running the Snapshot VMs Job Template

Now let's connect all the pieces through the AAP web interface and run the snapshot automation using a Job Template.

. Head to the AAP UI Dashboard, navigate to *Automation Execution → Templates*.

. Click *Create Template* and select *Create job template*.

. Fill in the following details:
+
[cols="2,3",options="header"]
|===
| Parameter | Value
| *Name* | Snapshot VMs
| *Job Type* | Run
| *Inventory* | OpenShift Virtual Machines
| *Project* | Workshop Project
| *Playbook* | solutions/manage_vm_playbook.yml
| *Execution Environment* | Day2 EE
| *Credentials* | OpenShift Credential
| *Extra variables* | `vm_namespace: vms-aap-day2` +
                      `task_file: snapshot_vms.yml` +
                      `vms_to_snapshot: rhel9-vm1`
|===

. Click *Create Job Template*.
+
image::module-01-day-to-day/71-create-snapshot.png[title="Create Snapshot Template", link=self, window=blank, width=100%]
+
. Launch the job by selecting *Launch Template* from the top-right corner.

=== Verifying Snapshot Creation

Once the Job completes successfully, confirm the new Snapshot has been created.

. Navigate to the OpenShift console and go to *Virtualization → VirtualMachines* within the `vms-aap-day2` project.

. Select the `rhel9-vm1` instance and click the *Snapshots* tab.

. Verify that the snapshot appears in the list.
+
image::module-01-day-to-day/72-ocp-snapshot-details.png[title="Snapshot Details", link=self, window=blank, width=100%]

=== Understanding the Provided Restoration Task Files

The restoration automation handles the complete workflow of stopping a VM, restoring from a snapshot, and restarting the VM. Unlike snapshot creation, a Virtual Machine must be powered off prior to initiating a restoration from a snapshot. This automation follows the same two-tiered pattern as the snapshot process.

=== restore_vm_snapshots.yml

This main task file processes a comma-delimited string of snapshot names and creates individual restoration tasks. The primary difference from the snapshot task is that it references snapshot names rather than VM names.

[source,yaml]
----
---
- name: Restore VM Snapshot
  ansible.builtin.include_tasks:
    file: _restore_vm_snapshot.yml
  loop_control:
    loop_var: vm_snapshot
  loop: "{{ vm_snapshots.replace(' ','').split(',') }}"
  when: vm_snapshots | default('', True) | length > 0
----

This task operates on a variable called `vm_snapshots` that contains a comma-delimited string of `VirtualMachineSnapshot` resource names to restore.

=== _restore_vm_snapshot.yml

This included task file manages the complete restoration workflow following these steps:

. Retrieve the `VirtualMachineSnapshot` based on the snapshot name provided
. Stop the Virtual Machine
. Create the `VirtualMachineRestore` resource and wait until restoration completes
. Start the Virtual Machine

[source,yaml]
----
---
- name: Verify VM Snapshot Provided
  ansible.builtin.assert:
    that:
      - vm_snapshot | default('', True) | length > 0
    quiet: True
    fail_msg: VM Snapshot not specified

- name: Get VirtualMachine Snapshot
  kubernetes.core.k8s_info:
    api_version: snapshot.kubevirt.io/v1alpha1
    kind: VirtualMachineSnapshot
    namespace: "{{ vm_namespace }}"
    name: "{{ vm_snapshot }}"
  register: vm_snapshot_instance

- name: Create Restore
  block:
    - name: Stop Virtual Machine
      redhat.openshift_virtualization.kubevirt_vm:
        name: "{{ vm_snapshot_instance.resources[0].metadata.ownerReferences[0].name }}"
        namespace: "{{ vm_snapshot_instance.resources[0].metadata.namespace }}"
        run_strategy: Halted
        wait: true

    - name: Create Restore
      redhat.openshift.k8s:
        state: present
        definition:
          apiVersion: snapshot.kubevirt.io/v1alpha1
          kind: VirtualMachineRestore
          metadata:
            generateName: "{{ vm_snapshot_instance.resources[0].metadata.ownerReferences[0].name }}-"
            namespace: "{{ vm_snapshot_instance.resources[0].metadata.namespace }}"
            ownerReferences:
              - apiVersion: kubevirt.io/v1
                blockOwnerDeletion: false
                kind: VirtualMachine
                name: "{{ vm_snapshot_instance.resources[0].metadata.ownerReferences[0].name }}"
                uid: "{{ vm_snapshot_instance.resources[0].metadata.ownerReferences[0].uid }}"
          spec:
            target:
              apiGroup: kubevirt.io
              kind: VirtualMachine
              name: "{{ vm_snapshot_instance.resources[0].metadata.ownerReferences[0].name }}"
            virtualMachineSnapshotName: "{{ vm_snapshot_instance.resources[0].metadata.name }}"
        wait: true
        wait_timeout: 600
        wait_condition:
          type: Ready

    - name: Start Virtual Machine
      redhat.openshift_virtualization.kubevirt_vm:
        name: "{{ vm_snapshot_instance.resources[0].metadata.ownerReferences[0].name }}"
        namespace: "{{ vm_snapshot_instance.resources[0].metadata.namespace }}"
        run_strategy: Always
        wait: true
  when: "'resources' in vm_snapshot_instance and vm_snapshot_instance.resources | length == 1"
----

**Explanation of the Tasks:**

* *kubernetes.core.k8s_info*: Retrieves the snapshot details to identify the associated VM (instead of `kubevirt_vm_info` which is specific to Virtual Machines, this allows retrieval of any OpenShift resource)
* *block*: Groups the restoration steps together with a conditional check at the end
* *Stop Virtual Machine*: Powers off the VM before restoration begins using `run_strategy: Halted`
* *Create Restore*: Creates the VirtualMachineRestore resource with a `wait_timeout` of 600 seconds (10 minutes) since restoration may take longer than the default 120 seconds
* *Start Virtual Machine*: Powers the VM back on after restoration completes using `run_strategy: Always`

=== Creating and Running the Restore VM Snapshots Job Template

. Head to the AAP UI Dashboard, navigate to *Automation Execution → Templates*.

. Click *Create Template* and select *Create job template*.

. Fill in the following details, making sure to include the name of the snapshot created previously:
+
[cols="2,3",options="header"]
|===
| Parameter | Value
| *Name* | Restore VM Snapshots
| *Job Type* | Run
| *Inventory* | OpenShift Virtual Machines
| *Project* | Workshop Project
| *Playbook* | solutions/manage_vm_playbook.yml
| *Execution Environment* | Day2 EE
| *Credentials* | OpenShift Credential
| *Extra variables* | `vm_namespace: vms-aap-day2` +
                      `task_file: restore_vm_snapshots.yml` +
                      `vm_snapshots: <snapshot_name>`
|===
+
WARNING: Replace `<snapshot_name>` with the actual name of your snapshot created previously.

. Click *Create Job Template*.
+
image::module-01-day-to-day/73-restore-snapshot.png[title="Restore Snapshot Template", link=self, window=blank, width=100%]

. Launch the template by clicking *Launch Template*.

=== Verifying Snapshot Restoration

Once the Job completes successfully, confirm the restoration was applied.

. Navigate to the OpenShift console and go to *Virtualization → VirtualMachines* within the `vms-aap-day2` project.

. Select the `rhel9-vm1` instance and click the *Snapshots* tab.

. Locate the snapshot you restored and verify the *Last restored* column shows the recent restoration timestamp.
+
image::module-01-day-to-day/74-ocp-restore-snapshot-details.png[title="Restore Snapshot Details", link=self, window=blank, width=100%]

== Summary

In this module you have spent a day in the life of an OpenShift Virtualization administrator exploring native performance assessment tools in Red Hat OpenShift, and making use of Ansible Automation Platform to automate a number of tasks that many VM's experience often on a day-to-day basis.
